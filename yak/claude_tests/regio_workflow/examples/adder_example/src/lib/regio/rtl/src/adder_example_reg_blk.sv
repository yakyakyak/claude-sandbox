//------------------------------------------------------------------------------
// adder_example register block module.
//
// NOTE: This file is autogenerated by regio. DO NOT EDIT.
//------------------------------------------------------------------------------

module adder_example_reg_blk (
    axi4l_intf.peripheral axil_if,
    adder_example_reg_intf.controller reg_blk_if
);

import adder_example_reg_pkg::*;

// -------------------------------------------------------------
// Terminate AXI-L interface
// -------------------------------------------------------------

reg_intf reg_if ();

axi4l_reg_peripheral i_axi4l_reg_peripheral (
    .axi4l_if (axil_if),
    .reg_if (reg_if)
);

// -------------------------------------------------------------
// Registers
// -------------------------------------------------------------

// ENABLE (1-bit, rw)
reg_rw #(reg_enable_t, INIT_ENABLE) enable_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .wr (reg_if.wr), .wr_en (reg_if.wr_addr == OFFSET_ENABLE), .wr_data (reg_if.wr_data), .wr_byte_en (reg_if.wr_byte_en),
    .rd_data (reg_blk_if.enable)
);

// OPERAND_A (32-bit, rw)
reg_rw #(reg_operand_a_t, INIT_OPERAND_A) operand_a_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .wr (reg_if.wr), .wr_en (reg_if.wr_addr == OFFSET_OPERAND_A), .wr_data (reg_if.wr_data), .wr_byte_en (reg_if.wr_byte_en),
    .rd_data (reg_blk_if.operand_a)
);

// OPERAND_B (32-bit, rw)
reg_rw #(reg_operand_b_t, INIT_OPERAND_B) operand_b_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .wr (reg_if.wr), .wr_en (reg_if.wr_addr == OFFSET_OPERAND_B), .wr_data (reg_if.wr_data), .wr_byte_en (reg_if.wr_byte_en),
    .rd_data (reg_blk_if.operand_b)
);

// RESULT (32-bit, ro)
reg_ro #(reg_result_t, INIT_RESULT) result_reg (
    .clk (reg_if.clk), .srst (reg_if.srst),
    .upd_en (reg_blk_if.result_nxt_v), .upd_data (reg_blk_if.result_nxt),
    .rd_data (reg_blk_if.result)
);

// -------------------------------------------------------------
// Write address decode
// -------------------------------------------------------------
initial begin
    reg_if.wr_ack = 1'b0;
    reg_if.wr_error = 1'b0;
end
always @(posedge reg_if.clk) begin
    if (reg_if.srst) begin
        reg_if.wr_ack <= 1'b0;
        reg_if.wr_error <= 1'b0;
    end else begin
        if (reg_if.wr) begin
            reg_if.wr_ack <= 1'b1;
            case (reg_if.wr_addr)
                OFFSET_ENABLE:                             reg_if.wr_error <= 1'b0;
                OFFSET_OPERAND_A:                          reg_if.wr_error <= 1'b0;
                OFFSET_OPERAND_B:                          reg_if.wr_error <= 1'b0;
                OFFSET_RESULT:                             reg_if.wr_error <= 1'b0;
                default:                                   reg_if.wr_error <= 1'b1;
            endcase
        end else begin
            reg_if.wr_ack <= 1'b0;
            reg_if.wr_error <= 1'b0;
        end
    end
end

// -------------------------------------------------------------
// Read address decode
// -------------------------------------------------------------
initial begin
    reg_if.rd_ack = 1'b0;
    reg_if.rd_error = 1'b0;
end
always @(posedge reg_if.clk) begin
    if (reg_if.srst) begin
        reg_if.rd_ack <= 1'b0;
        reg_if.rd_error <= 1'b0;
    end else begin
        if (reg_if.rd) begin
            reg_if.rd_ack <= 1'b1;
            case (reg_if.rd_addr)
                OFFSET_ENABLE:                             reg_if.rd_error <= 1'b0;
                OFFSET_OPERAND_A:                          reg_if.rd_error <= 1'b0;
                OFFSET_OPERAND_B:                          reg_if.rd_error <= 1'b0;
                OFFSET_RESULT:                             reg_if.rd_error <= 1'b0;
                default:                                   reg_if.rd_error <= 1'b1;
            endcase
        end else begin
            reg_if.rd_ack <= 1'b0;
            reg_if.rd_error <= 1'b0;
        end
    end
end

// -------------------------------------------------------------
// Read data mux
// -------------------------------------------------------------
always_ff @(posedge reg_if.clk) begin
    case (reg_if.rd_addr)
        OFFSET_ENABLE:                             reg_if.rd_data <= reg_blk_if.enable;
        OFFSET_OPERAND_A:                          reg_if.rd_data <= reg_blk_if.operand_a;
        OFFSET_OPERAND_B:                          reg_if.rd_data <= reg_blk_if.operand_b;
        OFFSET_RESULT:                             reg_if.rd_data <= reg_blk_if.result;
        default:                                   reg_if.rd_data <= reg_pkg::BAD_ACCESS_DATA;
    endcase
end

endmodule : adder_example_reg_blk
